use crate::{Poly, P, PE};
use ark_ff::{FftField, Field};
use ark_poly::{EvaluationDomain, Polynomial, Radix2EvaluationDomain};
use ark_std::{end_timer, start_timer};

#[derive(Clone, Debug, PartialEq)]
pub struct FftPoly<F: FftField> {
    pub poly: P<F>,
    evals: Option<PE<F>>,
}

impl<F: FftField> FftPoly<F> {
    pub fn new(poly: P<F>) -> Self {
        Self { poly, evals: None }
    }

    pub fn with_evals(poly: P<F>, evals: PE<F>) -> Self {
        debug_assert_eq!(evals.evals.len(), evals.domain().size());
        debug_assert!(poly.degree() <= evals.domain().size());
        Self {
            poly,
            evals: Some(evals),
        }
    }

    pub fn evals_for(&self, product_degree: usize) -> PE<F> {
        let evals_len = self.evals.as_ref().map_or(0, |evals| evals.evals.len());
        if evals_len * 2 >= product_degree {
            double_evals(&self.poly, self.evals.as_ref().unwrap())
        } else {
            let domain = Radix2EvaluationDomain::new(product_degree).unwrap();
            self.poly.evaluate_over_domain_by_ref(domain)
        }
    }

    #[cfg(feature = "parallel")]
    fn get_evals(a: &FftPoly<F>, b: &FftPoly<F>, ab_degree: usize) -> (PE<F>, PE<F>) {
        rayon::join(
            || a.evals_for(ab_degree),
            || b.evals_for(ab_degree))
    }

    #[cfg(not(feature = "parallel"))]
    fn get_evals(a: &FftPoly<F>, b: &FftPoly<F>, ab_degree: usize) -> (PE<F>, PE<F>) {
        (a.evals_for(ab_degree), b.evals_for(ab_degree))
    }

    pub fn mul(a: &FftPoly<F>, b: &FftPoly<F>) -> FftPoly<F> {
        let a_degree = a.poly.degree();
        let b_degree = b.poly.degree();
        let c_degree = a_degree + b_degree;

        if c_degree < 128 {
            // TODO
            let c = a.poly.naive_mul(&b.poly);
            return Self::new(c);
        }

        let (mut c_evals, b_evals) = Self::get_evals(a, b, c_degree);
        c_evals *= &b_evals;
        let c_evals_len = c_evals.evals.len();
        debug_assert_eq!(c_evals_len, c_evals.domain().size());
        let c = if c_evals_len > c_degree {
            c_evals.interpolate_by_ref()
        } else if c_evals_len == c_degree {
            let c_lc = a.poly.lc() * b.poly.lc();
            ifft_mod_z(&c_evals, c_lc)
        } else {
            panic!();
        };
        FftPoly::with_evals(c, c_evals)
    }
}

/// Given the evaluations of a polynomial `p` over `p_evals.domain`,
/// returns the evaluations of `p` over the twice larger domain,
/// i.e. generated by a square root of the generator of `p_evals.domain`.
pub fn double_evals<F: FftField>(p: &P<F>, p_evals: &PE<F>) -> PE<F> {
    let n = p_evals.domain().size();
    debug_assert_eq!(n, p_evals.evals.len());
    let domain_2x = Radix2EvaluationDomain::<F>::new(2 * n).unwrap();
    let w = domain_2x.group_gen();
    let coset = p_evals.domain().get_coset(w).unwrap();

    // let _t_coset_fft = start_timer!(|| format!("Coset FFT, n = {n}"));
    let pw_ewals = p.evaluate_over_domain_by_ref(coset);
    // end_timer!(_t_coset_fft);

    let evals_2x = interleave(&p_evals.evals, &pw_ewals.evals);
    let evals_2x = PE::from_vec_and_domain(evals_2x, domain_2x);
    debug_assert_eq!(evals_2x.evals.len(), domain_2x.size());
    evals_2x
}

pub fn interleave<F: Field>(a: &[F], b: &[F]) -> Vec<F> {
    debug_assert_eq!(a.len(), b.len());
    a.iter()
        .cloned()
        .zip(b.iter().cloned())
        .flat_map(|(ai, bi)| vec![ai, bi])
        .collect::<Vec<_>>()
}

/// Returns the unique monic polynomial of degree `n`, given its evaluations at `n` points.
pub fn ifft_mod_z<F: FftField>(p_evals: &PE<F>, p_lc: F) -> P<F> {
    let n = p_evals.domain().size();
    let mut r = p_evals.interpolate_by_ref();
    debug_assert!(r.degree() < n);
    // `p = r + k.(X^n - 1)`, see `test_mul_mod_z()`
    r.coeffs.resize(n + 1, F::zero());
    r.coeffs[0] -= p_lc;
    r.coeffs[n] = p_lc;
    r
}

#[cfg(test)]
mod tests {
    use super::*;
    use ark_bls12_381::Fr;
    use ark_ff::One;
    use ark_poly::{DenseUVPolynomial, Polynomial};
    use ark_std::test_rng;

    #[test]
    fn test_mul_mod_z() {
        let rng = &mut test_rng();

        let log_d = 2;
        let d = 2usize.pow(log_d);
        let p = P::<Fr>::rand(d, rng);
        let q = P::<Fr>::rand(d, rng);
        let pq = &p * &q;

        let domain_2d = Radix2EvaluationDomain::<Fr>::new(2 * d).unwrap();
        let z_2d: P<Fr> = domain_2d.vanishing_polynomial().into(); // X^{2d} - 1
        let p_evals = p.evaluate_over_domain_by_ref(domain_2d);
        let q_evals = q.evaluate_over_domain_by_ref(domain_2d);
        let pq_evals = &p_evals * &q_evals;
        let r = pq_evals.interpolate_by_ref();
        // `r(X) = p(X).q(X) mod (X^{2d} - 1), deg(r) < 2d`
        assert_eq!(r, pq.divide_by_vanishing_poly(domain_2d).1);
        // `p(X).q(X) = k(X).(X^{2d} - 1) + r(X)`
        // `k(X).(X^{2d} - 1) = p(X).q(X) - r(X) | deg(.)`
        // `deg(k) + 2d <= deg(pq) = 2d`, so `deg(k) = 0`

        // Taking `X := 0`, `k = r(0) - p(0).q(0)`
        let p_ct = p[0];
        let q_ct = q[0];
        let r_ct = r[0];
        let k = r_ct - p_ct * q_ct;
        assert_eq!(&r + &(&z_2d * k), pq);

        // Alternatively, as `der(r) < 2d`, `k = lc(pq)`
        let p_lc = p.coeffs[d];
        let q_lc = q.coeffs[d];
        let k = p_lc * q_lc;
        assert_eq!(&r + &(&z_2d * k), pq);
    }

    #[test]
    fn test_monic_interpolation() {
        let rng = &mut test_rng();

        let n = 4;
        let domain = Radix2EvaluationDomain::<Fr>::new(n).unwrap();

        let p = P::<Fr>::rand(n, rng);
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_ = ifft_mod_z(&p_evals, p.lc());
        assert_eq!(p_, p);
    }

    #[test]
    fn test_fft_doubling() {
        let rng = &mut test_rng();

        let n = 16;
        let p = P::<Fr>::rand(n - 1, rng);
        let domain = Radix2EvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = Radix2EvaluationDomain::<Fr>::new(2 * n).unwrap();
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_evals_2x = p.evaluate_over_domain_by_ref(domain_2x);

        let p_evals_2x_ = double_evals(&p, &p_evals);
        assert_eq!(p_evals_2x_, p_evals_2x);
    }

    // cargo test bench_fft_doubling --release --features="print-trace" -- --ignored --show-output
    #[test]
    #[ignore]
    fn bench_fft_doubling() {
        let rng = &mut test_rng();

        let log_n = 9; // as we end up with 2n evaluations
        let n = 2usize.pow(log_n);
        let p = P::<Fr>::rand(n - 1, rng);
        let domain = Radix2EvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = Radix2EvaluationDomain::<Fr>::new(2 * n).unwrap();

        let _t_fft_x2 = start_timer!(|| format!("2n-FFT, n = {n}"));
        let p_evals_2x = p.evaluate_over_domain_by_ref(domain_2x);
        end_timer!(_t_fft_x2); // 108.542µs
        println!();

        let _t_fft = start_timer!(|| format!("n-FFT + doubling, n = {n}"));
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_evals_2x_ = double_evals(&p, &p_evals);
        end_timer!(_t_fft); // 125.250µs
        println!();
        assert_eq!(p_evals_2x_, p_evals_2x);

        let _t_fft_doubling = start_timer!(|| format!("doubling precomputed n-FFT, n = {n}"));
        let p_evals_2x_ = double_evals(&p, &p_evals);
        end_timer!(_t_fft_doubling); // 70.916µs
        println!();
        assert_eq!(p_evals_2x_, p_evals_2x);
    }

    // cargo test bench_mul --release --features="print-trace" -- --ignored --show-output
    #[test]
    #[ignore]
    fn bench_mul() {
        let rng = &mut test_rng();

        let log_n = 9; // as we end up with `deg(c) = 2n`
        let n = 2usize.pow(log_n);
        let domain = Radix2EvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = Radix2EvaluationDomain::<Fr>::new(2 * n).unwrap();

        // deg(a) = deg(b) = n
        let mut a = P::<Fr>::rand(n, rng);
        let mut b = P::<Fr>::rand(n, rng);
        // but the polynomials are monic
        a.coeffs[n] = Fr::one();
        b.coeffs[n] = Fr::one();

        let _t_naive_mul = start_timer!(|| format!("Naive mul, n = {n}"));
        // uses FFTs of size `(2n + 1).next_power_of_two() = 4n`
        let c = &a * &b;
        end_timer!(_t_naive_mul); // 735.208µs
        println!();
        assert_eq!(c.degree(), 2 * n);
        let c_evals = c.evaluate_over_domain_by_ref(domain_2x);

        {
            let a = FftPoly::new(a.clone());
            let b = FftPoly::new(b.clone());
            let _t_monic_mul = start_timer!(|| format!("Monic mul, n = {n}"));
            let ab = FftPoly::mul(&a, &b);
            end_timer!(_t_monic_mul); // 553.416µs
            println!();
            assert_eq!(ab.poly, c);
            assert_eq!(ab.evals.unwrap(), c_evals);
        }

        {
            let a_evals = a.evaluate_over_domain_by_ref(domain);
            let b_evals = b.evaluate_over_domain_by_ref(domain);
            let a = FftPoly::with_evals(a, a_evals);
            let b = FftPoly::with_evals(b, b_evals);
            // Assumes that size `n` evaluations of the multiplicands are known.
            let _t_mul_with_evals = start_timer!(|| format!("Monic mul with evals, n = {n}"));
            let ab = FftPoly::mul(&a, &b);
            end_timer!(_t_mul_with_evals); // 487.292µs
            println!();
            assert_eq!(ab.poly, c);
            assert_eq!(ab.evals.unwrap(), c_evals);
        }
    }
}
