use crate::P;
use ark_ff::{FftField, Field};
use ark_poly::{EvaluationDomain, Evaluations, GeneralEvaluationDomain, Polynomial};
use ark_std::{end_timer, start_timer};

#[derive(Clone, Debug, PartialEq)]
pub struct Monic<F: FftField> {
    pub poly: P<F>,
    evals: Option<Evaluations<F>>,
}

impl<F: FftField> Monic<F> {
    pub fn new(poly: P<F>) -> Self {
        Self { poly, evals: None }
    }

    pub fn with_evals(poly: P<F>, evals: Evaluations<F>) -> Self {
        assert_eq!(poly.degree(), evals.domain().size());
        Self { poly, evals: Some(evals) }
    }

    pub fn evals_2x(&self) -> Evaluations<F> {
        match &self.evals {
            Some(evals) => double_evals(&self.poly, &evals),
            None => {
                let n = self.poly.degree();
                let domain_2x = GeneralEvaluationDomain::<F>::new(2 * n).unwrap();
                self.poly.evaluate_over_domain_by_ref(domain_2x)
            }
        }
    }

    pub fn mul(a: &Monic<F>, b: &Monic<F>) -> Monic<F> {
        let d = a.poly.degree();
        // assert_eq!(b.poly.degree(), d);

        if d < 64 {
            let c = a.poly.naive_mul(&b.poly);
            return Self::new(c);
        }

        let mut c_evals = a.evals_2x();
        c_evals *= &b.evals_2x();
        let c = monic_interpolation(&c_evals);
        Monic::with_evals(c, c_evals)
    }
}

/// Given the evaluations of a polynomial `p` over `p_evals.domain`,
/// returns the evaluations of `p` over the twice larger domain,
/// i.e. generated by a square root of the generator of `p_evals.domain`.
pub fn double_evals<F: FftField>(p: &P<F>, p_evals: &Evaluations<F>) -> Evaluations<F> {
    let n = p_evals.domain().size();
    let domain_2x = GeneralEvaluationDomain::<F>::new(2 * n).unwrap();
    let w = domain_2x.group_gen();
    let coset = p_evals.domain().get_coset(w).unwrap();

    let _t_coset_fft = start_timer!(|| format!("Coset FFT, n = {n}"));
    let pw_ewals = p.evaluate_over_domain_by_ref(coset);
    end_timer!(_t_coset_fft);

    let evals_2x = interleave(&p_evals.evals, &pw_ewals.evals);
    let evals_2x = Evaluations::from_vec_and_domain(evals_2x, domain_2x);
    evals_2x
}

pub fn interleave<F: Field>(a: &[F], b: &[F]) -> Vec<F> {
    debug_assert_eq!(a.len(), b.len());
    a.iter().cloned()
        .zip(b.iter().cloned())
        .flat_map(|(ai, bi)| vec![ai, bi])
        .collect::<Vec<_>>()
}

/// Returns the unique monic polynomial of degree `n`, given its evaluations at `n` points.
pub fn monic_interpolation<F: FftField>(p_evals: &Evaluations<F>) -> P<F> {
    // Let `p` be a degree `n` monic polynomial.
    // Then `p(X) = X^n + f(X)`, where `deg(f) < n`.
    // Then `f` can be interpolated using `n` evaluations `(xi, vi)`.
    // `f(X) = p(X) - X^n`
    // `f(xi) = vi - xi^n, i = 1,...,n`
    let n = p_evals.evals.len();
    let domain = p_evals.domain();
    let f_evals = p_evals.evals.iter()
        .zip(domain.elements())
        .map(|(vi, xi)| *vi - xi.pow([n as u64]))
        .collect::<Vec<_>>();
    let f_evals = Evaluations::from_vec_and_domain(f_evals, domain);
    let mut f = f_evals.interpolate();
    // p(X) = f(X) + X^n
    f.coeffs.resize(n + 1, F::zero());
    f.coeffs[n] = F::one();
    f
}

#[cfg(test)]
mod tests {
    use super::*;
    use ark_bls12_381::Fr;
    use ark_ff::{One, Zero};
    use ark_poly::{DenseUVPolynomial, Polynomial};
    use ark_std::test_rng;

    #[test]
    fn test_monic_interpolation() {
        let rng = &mut test_rng();

        let n = 4;
        let domain = GeneralEvaluationDomain::<Fr>::new(n).unwrap();

        let p: P<Fr> = domain.vanishing_polynomial().into();
        assert_eq!(p.degree(), n);
        assert!(p.coeffs[n].is_one()); // `p` is monic
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        assert_eq!(p_evals.evals, vec![Fr::zero(); n]);
        let p_ = monic_interpolation(&p_evals);
        assert_eq!(p_, p);

        let mut p = P::<Fr>::rand(n, rng);
        p.coeffs[n] = Fr::one();
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_ = monic_interpolation(&p_evals);
        assert_eq!(p_, p);
    }

    #[test]
    fn test_fft_doubling() {
        let rng = &mut test_rng();

        let n = 16;
        let p = P::<Fr>::rand(n - 1, rng);
        let domain = GeneralEvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = GeneralEvaluationDomain::<Fr>::new(2 * n).unwrap();
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_evals_2x = p.evaluate_over_domain_by_ref(domain_2x);

        let p_evals_2x_ = double_evals(&p, &p_evals);
        assert_eq!(p_evals_2x_, p_evals_2x);
    }

    // cargo test bench_fft_doubling --release --features="print-trace" -- --ignored --show-output
    #[test]
    #[ignore]
    fn bench_fft_doubling() {
        let rng = &mut test_rng();

        let log_n = 9; // as we end up with 2n evaluations
        let n = 2usize.pow(log_n);
        let p = P::<Fr>::rand(n - 1, rng);
        let domain = GeneralEvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = GeneralEvaluationDomain::<Fr>::new(2 * n).unwrap();

        let _t_fft_x2 = start_timer!(|| format!("2n-FFT, n = {n}"));
        let p_evals_2x = p.evaluate_over_domain_by_ref(domain_2x);
        end_timer!(_t_fft_x2); // 108.542µs
        println!();

        let _t_fft = start_timer!(|| format!("n-FFT + doubling, n = {n}"));
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_evals_2x_ = double_evals(&p, &p_evals);
        end_timer!(_t_fft); // 125.250µs
        println!();
        assert_eq!(p_evals_2x_, p_evals_2x);

        let _t_fft_doubling = start_timer!(|| format!("doubling precomputed n-FFT, n = {n}"));
        let p_evals_2x_ = double_evals(&p, &p_evals);
        end_timer!(_t_fft_doubling); // 70.916µs
        println!();
        assert_eq!(p_evals_2x_, p_evals_2x);
    }

    // cargo test bench_mul --release --features="print-trace" -- --ignored --show-output
    #[test]
    #[ignore]
    fn bench_mul() {
        let rng = &mut test_rng();

        let log_n = 9; // as we end up with `deg(c) = 2n`
        let n = 2usize.pow(log_n);
        let domain = GeneralEvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = GeneralEvaluationDomain::<Fr>::new(2 * n).unwrap();

        // deg(a) = deg(b) = n
        let mut a = P::<Fr>::rand(n, rng);
        let mut b = P::<Fr>::rand(n, rng);
        // but the polynomials are monic
        a.coeffs[n] = Fr::one();
        b.coeffs[n] = Fr::one();

        let _t_naive_mul = start_timer!(|| format!("Naive mul, n = {n}"));
        // uses FFTs of size `(2n + 1).next_power_of_two() = 4n`
        let c = &a * &b;
        end_timer!(_t_naive_mul); // 735.208µs
        println!();
        assert_eq!(c.degree(), 2 * n);
        let c_evals = c.evaluate_over_domain_by_ref(domain_2x);

        {
            let a = Monic::new(a.clone());
            let b = Monic::new(b.clone());
            let _t_monic_mul = start_timer!(|| format!("Monic mul, n = {n}"));
            let ab = Monic::mul(&a, &b);
            end_timer!(_t_monic_mul); // 553.416µs
            println!();
            assert_eq!(ab.poly, c);
            assert_eq!(ab.evals.unwrap(), c_evals);
        }

        {
            let a_evals = a.evaluate_over_domain_by_ref(domain);
            let b_evals = b.evaluate_over_domain_by_ref(domain);
            let a = Monic::with_evals(a, a_evals);
            let b = Monic::with_evals(b, b_evals);
            // Assumes that size `n` evaluations of the multiplicands are known.
            let _t_mul_with_evals = start_timer!(|| format!("Monic mul with evals, n = {n}"));
            let ab = Monic::mul(&a, &b);
            end_timer!(_t_mul_with_evals); // 487.292µs
            println!();
            assert_eq!(ab.poly, c);
            assert_eq!(ab.evals.unwrap(), c_evals);
        }
    }
}