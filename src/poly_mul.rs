use crate::P;
use ark_ff::{FftField, Field};
use ark_poly::{DenseUVPolynomial, EvaluationDomain, Evaluations, GeneralEvaluationDomain, Polynomial};
use ark_std::{end_timer, start_timer};

#[derive(Clone, Debug, PartialEq)]
pub struct Monic<F: FftField> {
    pub poly: P<F>,
    evals: Option<Evaluations<F>>,
}

impl<F: FftField> Monic<F> {
    pub fn new(poly: P<F>) -> Self {
        Self { poly, evals: None }
    }

    pub fn with_evals(poly: P<F>, evals: Evaluations<F>) -> Self {
        debug_assert_eq!(evals.evals.len(), evals.domain().size());
        debug_assert!(poly.degree() <= evals.domain().size());
        Self { poly, evals: Some(evals) }
    }

    pub fn evals_for(&self, product_degree: usize) -> Evaluations<F> {
        let evals_len = self.evals.as_ref().map_or(0, |evals| evals.evals.len());
        if evals_len * 2 >= product_degree {
            double_evals(&self.poly, self.evals.as_ref().unwrap())
        } else {
            let domain = GeneralEvaluationDomain::new(product_degree).unwrap();
            self.poly.evaluate_over_domain_by_ref(domain)
        }
    }

    pub fn mul(a: &Monic<F>, b: &Monic<F>) -> Monic<F> {
        let a_degree = a.poly.degree();
        let b_degree = b.poly.degree();
        debug_assert!(a_degree.abs_diff(b_degree) <= 1);
        let c_degree = a_degree + b_degree;

        if c_degree < 128 { // TODO
            let c = a.poly.naive_mul(&b.poly);
            return Self::new(c);
        }

        let mut c_evals = a.evals_for(c_degree);
        c_evals *= &b.evals_for(c_degree);
        let c_evals_len = c_evals.evals.len();
        debug_assert_eq!(c_evals_len, c_evals.domain().size());
        let c = if c_evals_len > c_degree {
            c_evals.interpolate_by_ref()
        } else {
            monic_interpolation(&c_evals)
        };
        Monic::with_evals(c, c_evals)
    }
}

/// Given the evaluations of a polynomial `p` over `p_evals.domain`,
/// returns the evaluations of `p` over the twice larger domain,
/// i.e. generated by a square root of the generator of `p_evals.domain`.
pub fn double_evals<F: FftField>(p: &P<F>, p_evals: &Evaluations<F>) -> Evaluations<F> {
    let n = p_evals.domain().size();
    debug_assert_eq!(n, p_evals.evals.len());
    let domain_2x = GeneralEvaluationDomain::<F>::new(2 * n).unwrap();
    let w = domain_2x.group_gen();
    let coset = p_evals.domain().get_coset(w).unwrap();

    let _t_coset_fft = start_timer!(|| format!("Coset FFT, n = {n}"));
    let pw_ewals = p.evaluate_over_domain_by_ref(coset);
    end_timer!(_t_coset_fft);

    let evals_2x = interleave(&p_evals.evals, &pw_ewals.evals);
    let evals_2x = Evaluations::from_vec_and_domain(evals_2x, domain_2x);
    debug_assert_eq!(evals_2x.evals.len(), domain_2x.size());
    evals_2x
}

pub fn interleave<F: Field>(a: &[F], b: &[F]) -> Vec<F> {
    debug_assert_eq!(a.len(), b.len());
    a.iter().cloned()
        .zip(b.iter().cloned())
        .flat_map(|(ai, bi)| vec![ai, bi])
        .collect::<Vec<_>>()
}

/// Returns the unique monic polynomial of degree `n`, given its evaluations at `n` points.
pub fn monic_interpolation<F: FftField>(p_evals: &Evaluations<F>) -> P<F> {
    let n = p_evals.domain().size();
    let mut r = p_evals.interpolate_by_ref();
    debug_assert!(r.degree() < n);
    // `p = r + (X^n - 1)`, see `test_mul_mod_z()`
    r.coeffs.resize(n + 1, F::zero());
    r.coeffs[0] -= F::one();
    r.coeffs[n] = F::one();
    r
}

#[cfg(test)]
mod tests {
    use super::*;
    use ark_bls12_381::Fr;
    use ark_ff::One;
    use ark_poly::{DenseUVPolynomial, Polynomial};
    use ark_std::test_rng;

    #[test]
    fn test_mul_mod_z() {
        let rng = &mut test_rng();

        let log_d = 2;
        let d = 2usize.pow(log_d);
        let p = P::<Fr>::rand(d, rng);
        let q = P::<Fr>::rand(d, rng);
        let pq = &p * &q;

        let domain_2d = GeneralEvaluationDomain::<Fr>::new(2 * d).unwrap();
        let z_2d: P<Fr> = domain_2d.vanishing_polynomial().into(); // X^{2d} - 1
        let p_evals = p.evaluate_over_domain_by_ref(domain_2d);
        let q_evals = q.evaluate_over_domain_by_ref(domain_2d);
        let pq_evals = &p_evals * &q_evals;
        let r = pq_evals.interpolate_by_ref();
        // `r(X) = p(X).q(X) mod (X^{2d} - 1), deg(r) < 2d`
        assert_eq!(r, pq.divide_by_vanishing_poly(domain_2d).1);
        // `p(X).q(X) = k(X).(X^{2d} - 1) + r(X)`
        // `k(X).(X^{2d} - 1) = p(X).q(X) - r(X) | deg(.)`
        // `deg(k) + 2d <= deg(pq) = 2d`, so `deg(k) = 0`

        // Taking `X := 0`, `k = r(0) - p(0).q(0)`
        let p_ct = p[0];
        let q_ct = q[0];
        let r_ct = r[0];
        let k = r_ct - p_ct * q_ct;
        assert_eq!(&r + &(&z_2d * k), pq);

        // Alternatively, as `der(r) < 2d`, `k = lc(pq)`
        let p_lc = p.coeffs[d];
        let q_lc = q.coeffs[d];
        let k = p_lc * q_lc;
        assert_eq!(&r + &(&z_2d * k), pq);
    }

    #[test]
    fn test_monic_interpolation() {
        let rng = &mut test_rng();

        let n = 4;
        let domain = GeneralEvaluationDomain::<Fr>::new(n).unwrap();

        let mut p = P::<Fr>::rand(n, rng);
        p.coeffs[n] = Fr::one();
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_ = monic_interpolation(&p_evals);
        assert_eq!(p_, p);
    }

    #[test]
    fn test_fft_doubling() {
        let rng = &mut test_rng();

        let n = 16;
        let p = P::<Fr>::rand(n - 1, rng);
        let domain = GeneralEvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = GeneralEvaluationDomain::<Fr>::new(2 * n).unwrap();
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_evals_2x = p.evaluate_over_domain_by_ref(domain_2x);

        let p_evals_2x_ = double_evals(&p, &p_evals);
        assert_eq!(p_evals_2x_, p_evals_2x);
    }

    // cargo test bench_fft_doubling --release --features="print-trace" -- --ignored --show-output
    #[test]
    #[ignore]
    fn bench_fft_doubling() {
        let rng = &mut test_rng();

        let log_n = 9; // as we end up with 2n evaluations
        let n = 2usize.pow(log_n);
        let p = P::<Fr>::rand(n - 1, rng);
        let domain = GeneralEvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = GeneralEvaluationDomain::<Fr>::new(2 * n).unwrap();

        let _t_fft_x2 = start_timer!(|| format!("2n-FFT, n = {n}"));
        let p_evals_2x = p.evaluate_over_domain_by_ref(domain_2x);
        end_timer!(_t_fft_x2); // 108.542µs
        println!();

        let _t_fft = start_timer!(|| format!("n-FFT + doubling, n = {n}"));
        let p_evals = p.evaluate_over_domain_by_ref(domain);
        let p_evals_2x_ = double_evals(&p, &p_evals);
        end_timer!(_t_fft); // 125.250µs
        println!();
        assert_eq!(p_evals_2x_, p_evals_2x);

        let _t_fft_doubling = start_timer!(|| format!("doubling precomputed n-FFT, n = {n}"));
        let p_evals_2x_ = double_evals(&p, &p_evals);
        end_timer!(_t_fft_doubling); // 70.916µs
        println!();
        assert_eq!(p_evals_2x_, p_evals_2x);
    }

    // cargo test bench_mul --release --features="print-trace" -- --ignored --show-output
    #[test]
    #[ignore]
    fn bench_mul() {
        let rng = &mut test_rng();

        let log_n = 9; // as we end up with `deg(c) = 2n`
        let n = 2usize.pow(log_n);
        let domain = GeneralEvaluationDomain::<Fr>::new(n).unwrap();
        let domain_2x = GeneralEvaluationDomain::<Fr>::new(2 * n).unwrap();

        // deg(a) = deg(b) = n
        let mut a = P::<Fr>::rand(n, rng);
        let mut b = P::<Fr>::rand(n, rng);
        // but the polynomials are monic
        a.coeffs[n] = Fr::one();
        b.coeffs[n] = Fr::one();

        let _t_naive_mul = start_timer!(|| format!("Naive mul, n = {n}"));
        // uses FFTs of size `(2n + 1).next_power_of_two() = 4n`
        let c = &a * &b;
        end_timer!(_t_naive_mul); // 735.208µs
        println!();
        assert_eq!(c.degree(), 2 * n);
        let c_evals = c.evaluate_over_domain_by_ref(domain_2x);

        {
            let a = Monic::new(a.clone());
            let b = Monic::new(b.clone());
            let _t_monic_mul = start_timer!(|| format!("Monic mul, n = {n}"));
            let ab = Monic::mul(&a, &b);
            end_timer!(_t_monic_mul); // 553.416µs
            println!();
            assert_eq!(ab.poly, c);
            assert_eq!(ab.evals.unwrap(), c_evals);
        }

        {
            let a_evals = a.evaluate_over_domain_by_ref(domain);
            let b_evals = b.evaluate_over_domain_by_ref(domain);
            let a = Monic::with_evals(a, a_evals);
            let b = Monic::with_evals(b, b_evals);
            // Assumes that size `n` evaluations of the multiplicands are known.
            let _t_mul_with_evals = start_timer!(|| format!("Monic mul with evals, n = {n}"));
            let ab = Monic::mul(&a, &b);
            end_timer!(_t_mul_with_evals); // 487.292µs
            println!();
            assert_eq!(ab.poly, c);
            assert_eq!(ab.evals.unwrap(), c_evals);
        }
    }
}